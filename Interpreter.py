from typing import Any, Generator, Tuple, List, Dict
from AST_Tree import ASTNode
from errors import InterpreterError

class Interpreter:
    def __init__(self, debug: bool = False) -> None:
        self.variables: Dict[str, Any] = {} # dictionary for values of variables
        self.output: List[Any] = [] # list to store output values
        self.debug: bool = debug # enable/disable debug

    # interpreter -- evaluates AST generated by the parser and executes the program.
    def interpret(self, node: ASTNode) -> Tuple[str, List[Any], Dict[str, Any]]:
        self.output.clear()
        try:
            self.visit(node) # start from the root
            return "success", self.output, self.variables # if success, return status, output, and variables
        except Exception as e:
            return f"fail: {str(e)}", self.output, self.variables # if error, return fail status with message

    # visit -- find the correct visitor method based on node
    def visit(self, node: ASTNode) -> Any:
        method_name = f'visit_{node.kind}' # create the method name based on the node kind
        visitor = getattr(self, method_name, self.generic_visit) # get the method or use the generic_visit if not found
        return visitor(node) # return the result of the visitor method

    # generic visit -- handles nodes that do not have a specific visitor method
    def generic_visit(self, node: ASTNode) -> Any:
        raise InterpreterError(f"No method visit_{node.kind}") # raise an exception if no specific visitor method is found

# visitor methods for each node type
    # visit the program node
    def visit_Program(self, node: ASTNode) -> None:
        for child in node.children:
            self.visit(child) # visit each child

    # visit assignment nodes
    def visit_Assign(self, node: ASTNode) -> None:
        var_name = node.children[0].value # get the variable name from the first child node
        value = self.visit(node.children[1]) # visit the expression node to get its value
        self.variables[var_name] = value # assign the value in the dictionary

    # visit variable nodes to get their value
    def visit_Var(self, node: ASTNode) -> Any:
        if node.value not in self.variables:
            raise InterpreterError(f"Runtime Error: Variable '{node.value}' not assigned.") # if the variable is not assigned, error
        return self.variables[node.value] # else return the value of the var

    # visit string literal nodes to return their value
    def visit_String(self, node: ASTNode) -> str:
        return node.value

    # visit integer literal nodes and return them as integers
    def visit_Int(self, node: ASTNode) -> int:
        return int(node.value)

    # visit binary operation nodes to get the result of the operation
    def visit_BinOp(self, node: ASTNode) -> Any:
        left = self.visit(node.children[0]) # visit left operand
        right = self.visit(node.children[1]) # visit right operand
        op = node.value # get the operator value 
        # handle different operators
        if op == '+':
            return left + right
        if op == '-':
            return left - right
        if op == '*':
            return left * right
        # handle division by zero error
        if op == '/':
            if right == 0:
                raise InterpreterError("Runtime Error: Division by zero.")
            return left // right
        if op == '%':
            return left % right
        raise InterpreterError(f"Unknown operator: {op}")

    # visit logical operation nodes to get the result of the operation
    def visit_LogicOp(self, node: ASTNode) -> bool:
        left = self.visit(node.children[0]) # visit left operand
        right = self.visit(node.children[1]) # visit right operand
        # handle cases for different operators
        if node.value == '&&':
            return left and right
        if node.value == '||':
            return left or right
        raise InterpreterError(f"Unknown logic operator: {node.value}")

    # visit relational operation nodes to get the result of the operation
    def visit_RelOp(self, node: ASTNode) -> bool:
        left = self.visit(node.children[0]) # visit left operand
        right = self.visit(node.children[1]) # visit right operand
        # handle the cases for different operators
        if node.value == '==':
            return left == right
        if node.value == '!=':
            return left != right
        if node.value == '>':
            return left > right
        if node.value == '<':
            return left < right
        if node.value == '>=':
            return left >= right
        if node.value == '<=':
            return left <= right
        raise InterpreterError(f"Unknown relational operator: {node.value}")

    # visit if statement nodes to evaluate the condition
    def visit_If(self, node: ASTNode) -> None:
        condition = self.visit(node.children[0]) # get the value of the condition node
        # if true, visit each statement in body of the if()
        if condition:
            for stmt in node.children[1:]:
                self.visit(stmt)

    # visit loop statement nodes to evaluate the loop variable and its range
    def visit_Loop(self, node: ASTNode) -> None:
        loop_var = node.children[0].value # get the loop variable name
        start = self.visit(node.children[1]) # visit start to get its value
        end = self.visit(node.children[2]) # visit end to get its value
        
        # for each iteration, assign the loop variable to the current value of i
        for i in range(start, end + 1):
            self.variables[loop_var] = i
            # visit each statement in the body of the loop
            for stmt in node.children[3:]:
                self.visit(stmt)

    # visit print_statement nodes to print the value
    def visit_Print(self, node: ASTNode) -> Any:
        value = self.visit(node.children[0]) # visit expression to get its value
        self.output.append(value) # append the value to the output list
        return value # return the value



# Step-Interpreter
    #  interpret_step to take one step of the execution process
    def interpret_step(self, node: ASTNode) -> Generator[str, None, None]:
        self.variables.clear() # clear the variables
        self.output.clear() # clear the output
        yield "Starting step-by-step interpretation...\n"
        yield from self.step_visit(node) # start from the root
        yield "Interpretation complete."

    # visit each node in to decide the action we will take
    def step_visit(self, node: ASTNode) -> Generator[str, None, Any]:
        yield f"Visiting {node.kind} (value: {node.value})" # yield the kind and value
        method_name = f"step_visit_{node.kind}" 
        visitor = getattr(self, method_name, self.generic_step_visit)
        result = yield from visitor(node) # call the correct method based on the node
        yield f"Result of {node.kind}: {result}" # get the result of the node
        return result # return it

    # generic visit if the node is not defined
    def generic_step_visit(self, node: ASTNode) -> Generator[str, None, Any]:
        raise InterpreterError(f"No step_visit method for {node.kind}") # description of missing node

    # visit the program node
    def step_visit_Program(self, node: ASTNode) -> Generator[str, None, Any]:
        result = None
        for child in node.children:
            result = yield from self.step_visit(child) # visit each child
        return result # return the result

    # visit method for assignment nodes
    def step_visit_Assign(self, node: ASTNode) -> Generator[str, None, Any]:
        var_name = node.children[0].value # get the var name of the first node
        expr_result = yield from self.step_visit(node.children[1]) # get the value of the expression node
        self.variables[var_name] = expr_result # assign the value to the var
        yield f"Assigned {var_name} = {expr_result}" # yield the result
        return expr_result # return the value

    # visit the variables to get their value
    def step_visit_Var(self, node: ASTNode) -> Generator[str, None, Any]:
        
        # if the variable is not assigned -- error
        if node.value not in self.variables:
            raise InterpreterError(f"Runtime Error: Variable '{node.value}' not assigned.")
        
        result = self.variables[node.value]
        yield f"Variable {node.value} = {result}"
        return result # return the value

    # visit string to get their literal value
    def step_visit_String(self, node: ASTNode) -> Generator[str, None, Any]:
        result = node.value
        yield f"String literal: {result}"
        return result # return the string literal

    # visit int literals and to get and convert their values to int
    def step_visit_Int(self, node: ASTNode) -> Generator[str, None, Any]:
        result = int(node.value)
        yield f"Integer literal: {result}"
        return result # return the int literal

    # visit binary operations to yield the correct result
    def step_visit_BinOp(self, node: ASTNode) -> Generator[str, None, Any]:
        left = yield from self.step_visit(node.children[0]) # visit left operand
        right = yield from self.step_visit(node.children[1]) # visit right operand
        op = node.value # get the operator node
        # use the correct action for the operand
        if op == '+':
            result = left + right
        elif op == '-':
            result = left - right
        elif op == '*':
            result = left * right
        elif op == '/':
            # catch division by zero errors
            if right == 0:
                raise InterpreterError("Runtime Error: Division by zero.")
            result = left // right
        elif op == '%':
            result = left % right
        # catch unknown operators
        else:
            raise InterpreterError(f"Unknown operator: {op}")
        yield f"Computed {left} {op} {right} = {result}" # calculate the result
        return result # return it

    # visit logical operators to yield the correct result
    def step_visit_LogicOp(self, node: ASTNode) -> Generator[str, None, Any]:
        left = yield from self.step_visit(node.children[0]) # visit left operand
        right = yield from self.step_visit(node.children[1]) # visit right operand
        # use the correct action value based on the operator
        if node.value == '&&':
            result = left and right
        elif node.value == '||':
            result = left or right
        # catch unknown operator errors
        else:
            raise InterpreterError(f"Unknown logic operator: {node.value}")
        yield f"Computed {left} {node.value} {right} = {result}" # compute the result
        return result # return it

    # visit relative operations to yield the correct result
    def step_visit_RelOp(self, node: ASTNode) -> Generator[str, None, Any]:
        left = yield from self.step_visit(node.children[0]) # visit left operand
        right = yield from self.step_visit(node.children[1]) # visit right operand
        # use the correct action value based on the operator
        if node.value == '==':
            result = left == right
        elif node.value == '!=':
            result = left != right
        elif node.value == '>':
            result = left > right
        elif node.value == '<':
            result = left < right
        elif node.value == '>=':
            result = left >= right
        elif node.value == '<=':
            result = left <= right
        else:
            # catch unknown operator errors
            raise InterpreterError(f"Unknown relational operator: {node.value}")
        yield f"Computed {left} {node.value} {right} = {result}" # compute the result
        return result # return it

    # visit visit if statements to calculate the proper conditions
    def step_visit_If(self, node: ASTNode) -> Generator[str, None, Any]:
        condition = yield from self.step_visit(node.children[0]) # visit the condition node to get its value
        yield f"If condition evaluated to {condition}" # get the result of the condition
        
        # if the condition is true, visit each statement in the body
        if condition:
            for stmt in node.children[1:]:
                yield from self.step_visit(stmt)
        return None # no need to return a value

    # visit loop statements to calculate their range
    def step_visit_Loop(self, node: ASTNode) -> Generator[str, None, Any]:
        loop_var = node.children[0].value # get the loop var nam from initial node
        start = yield from self.step_visit(node.children[1]) # visit start expression to get its value
        end = yield from self.step_visit(node.children[2]) # visit end expression to get its value
        yield f"Loop: {loop_var} from {start} to {end}" # yield the loop range.
        # for each iteration, assign the loop variable to the current value of i
        for i in range(start, end + 1):
            self.variables[loop_var] = i
            yield f"Loop iteration: {loop_var} = {i}"
            # visit each statement in the body of the loop
            for stmt in node.children[3:]:
                yield from self.step_visit(stmt)
        return None # no need to return a value

    # visit print statements to yield their results
    def step_visit_Print(self, node: ASTNode) -> Generator[str, None, Any]:
        value = yield from self.step_visit(node.children[0]) # visit the expression node to get its value
        self.output.append(value) # append the value to the output
        yield f"Printed: {value}" # yield it
        return value # return it
