from errors import ParserError
from lexer import TokenType
# cSpell:ignore MULT_OP



# parse the tokens generated by the lexer
class Parser:
    # initializations
    def __init__(self, tokens, source_code=None):
        self.tokens = tokens  # list of tokens
        self.index = 0 # set the current index to 0
        self.current_token = None # set current token to none
        self.source_code = source_code # get the source code
        self.errors = []  # used to collect errors
        self.advance()  # used to advance the token

# token management
    # advance to the next token
    def advance(self):
        # if more tokens exist
        if self.index < len(self.tokens):
            self.current_token = self.tokens[self.index] # set the index to the next token
            self.index += 1 # increment
        # else there are no more tokens
        else:
            self.current_token = None # set the current token to None

    # check the next token -- without consuming
    def peek(self, offset=0):
        idx = self.index + offset # calculate the index of the next token
        return self.tokens[idx] if idx < len(self.tokens) else None # return the token if its in bounds

    # token matching if it is the right token
    def match(self, expected_token):
        # if the current token matches the expected token
        if self.current_token and self.current_token.token_type == expected_token:
            self.advance() # advance
        # else if it does not match
        else:
            self.error(f"Expected {expected_token}") # error

# error handling
    # handle the errors
    def error(self, message, line_override=None, column_override=None):
            # figure out the line
            if line_override is not None:
                line = line_override
            elif self.current_token:
                line = self.current_token.line
            else:
                line = "unknown"
            # figure out the column
            if column_override is not None:
                column = column_override
            elif self.current_token and hasattr(self.current_token, "column"):
                column = self.current_token.column
            else:
                column = None
            # raise the error
            raise ParserError(message, line=line, column=column, lexeme=(self.current_token.lexeme if self.current_token else None))

# grammar rules
    # <program> -> program <statements> end_program
    def program(self):
        # if the next token is PROGRAM
        if self.current_token and self.current_token.token_type == TokenType.PROGRAM:
            start_line = self.current_token.line
            self.advance() # consume it
            self.statements() # parse statements
            # else if the next token is END_PROGRAM
            if self.current_token and self.current_token.token_type == TokenType.END_P:
                self.advance() # consume it
            else:
                
                # if the current token is None and there are tokens left -- when a program ends without END_PROGRAM
                if self.current_token is None and self.tokens:
                    last_line = self.tokens[-1].line + 1 # get the last line
                    self.error("Expecting 'end_program'", last_line) # error
                    
                # else if the current token is not None -- the last token is not END_PROGRAM
                else:
                    self.error("Expecting 'end_program'", start_line) # get the line number
        else:
            # else if the current token is None and there are tokens left -- the program did not start with PROGRAM
            self.error("Expecting 'program'")

    # <statements> -> <statement> <statements> | <empty>
    def statements(self):
        if (self.current_token is None or 
            self.current_token.token_type in [TokenType.END_P, TokenType.END_IF, TokenType.END_LOOP]):
            return # empty
        self.statement() # parse one statement
        self.statements() # parse additional statements

    # <statement> -> <assignment> | <if_statement> | <loop_statement> | <print_statement>
    def statement(self):
        # if the statement is a print statement
        if self.current_token and self.current_token.token_type == TokenType.PRINT:
            start_line = self.current_token.line
            self.print_statement() # handle print
            # if its a semi
            if self.current_token and self.current_token.token_type == TokenType.SEMI:
                self.advance() # advance
            # else missing semi
            else:
                self.error("Expecting semicolon ';'", start_line) # error
            return

        # if we encounter a LEFT_PAREN, use our peek method
        if self.current_token and self.current_token.token_type == TokenType.LEFT_PAREN:
            next_tok = self.peek(1)
            # if we encounter a comparison operator directly after LEFT_PAREN
            if next_tok and next_tok.token_type in {
                TokenType.EQUALS, TokenType.NOT_EQUALS,
                TokenType.GREATER_THAN, TokenType.LESS_THAN,
                TokenType.GREATER_EQ, TokenType.LESS_EQ
            }:
                self.error("Missing 'if' before '('") # report importer IF
                
            # this will check for malformed loops -- find the ASSIGN_OP
            if self.peek(1) and self.peek(1).token_type == TokenType.ASSIGN_OP:
                i = 2
                # find the COLON
                while (tok := self.peek(i)) and tok.token_type != TokenType.RIGHT_PAREN:
                    if tok.token_type == TokenType.COLON:
                        self.error("Missing 'loop' before '('") # error
                    i += 1
        # proper if statement?
        if self.current_token and self.current_token.token_type == TokenType.IF_STMT:
            self.if_statement() # parse it
            # if we encounter a semi
            if self.current_token and self.current_token.token_type == TokenType.SEMI:
                self.advance() # advance
        # proper loop statement?
        elif self.current_token and self.current_token.token_type == TokenType.LOOP:
            self.loop_statement() # parse it
            # if we encounter semi
            if self.current_token and self.current_token.token_type == TokenType.SEMI:
                self.advance() # advance
        else:
            start_line = self.current_token.line if self.current_token else None # save line number
            self.assignment() # parse the assignment
            # if we have a semi next
            if self.current_token and self.current_token.token_type == TokenType.SEMI:
                self.advance() # advance
            # else -- we're missing a semi
            elif self.current_token and self.current_token.token_type in [TokenType.IDENT, TokenType.INT_LIT]:
                self.error("Expecting semicolon ';'", start_line + 1) # error
            else:
                # we're missing a semi and hitting other tokens
                if start_line is not None:
                    self.error("Expecting semicolon ';'", start_line + 1) # error with line number
                else:
                    self.error("Expecting semicolon ';'") # error without line number

    # <assignment> -> <var> = <expr>
    def assignment(self):
        self.var() # parse the var
        # if the next token is ASSIGN_OP
        if self.current_token and self.current_token.token_type == TokenType.ASSIGN_OP:
            self.advance() # consume it
            self.expr() # parse the expression
        else:
            # else... missing ASSIGN_OP
            self.error("Expecting assignment operator '='") # error

    # <var> -> IDENT
    def var(self):
        # if the current token is an IDENT
        if self.current_token and self.current_token.token_type == TokenType.IDENT:
            self.advance()  # consume it
        else:
            # else we're missing an IDENT
            self.error("Expecting identifier") # error

    # <expr> -> <term> {(+|-) <term>}
    def expr(self):
        self.term() # parse one term
        # if we have "+" or "-" next
        while self.current_token and self.current_token.token_type in [TokenType.ADD_OP, TokenType.SUB_OP]:
            self.advance() # consume it
            self.term() # parse the next term

    # <term> -> <factor> {(*|/|%) <factor>}
    def term(self):
        self.factor() # parse one factor
        # if we have "*", "/", or "%" next
        while self.current_token and self.current_token.token_type in [TokenType.MULT_OP, TokenType.DIV_OP, TokenType.MOD_OP]:
            self.advance()  # consume it
            self.factor() # parse the next factor

    def var_or_literal(self):
        # if the current token is an IDENT or INT_LIT
        if self.current_token and self.current_token.token_type in (TokenType.IDENT, TokenType.INT_LIT):
            self.advance() # consume it
        else:
            # else...
            self.error("Expecting identifier or integer literal") # error

    # <factor> -> <var> | INT_LIT | STRING_LIT | ( <expr> )
    def factor(self):
        # if the token is a IDENTIFIER
        if self.current_token and self.current_token.token_type == TokenType.IDENT:
            self.var() # parse it as a variable
        # else if the token is INT_LIT
        elif self.current_token and self.current_token.token_type == TokenType.INT_LIT:
            self.advance()  # consume it
        # else if the token is a STRING
        elif self.current_token and self.current_token.token_type == TokenType.STRING_LIT:
            self.advance()  # consume it
        # else if the token is LEFT_PAREN
        elif self.current_token and self.current_token.token_type == TokenType.LEFT_PAREN:
            self.advance() # consume it
            self.expr() # parse the expression
            # If we encounter the RIGHT_PAREN
            if self.current_token and self.current_token.token_type == TokenType.RIGHT_PAREN:
                self.advance() # consume it
                
            # else we are missing the RIGHT_PAREN
            else:
                self.error("Expecting right parenthesis ')'") # error
        # else we have improper parameters
        else:
            self.error("Expecting variable, integer literal, string literal, or expression") # error

    # <print_statement> -> PRINT ( <expr> )
    def print_statement(self):
        self.match(TokenType.PRINT) # parse the PRINT function
        self.match(TokenType.LEFT_PAREN) # parse the left paren
        self.expr() # parse the expression
        self.match(TokenType.RIGHT_PAREN) # parse the right paren

    # <if_statement> -> if ( <logic_expr> ) <statements> end_if
    def if_statement(self):
        start_line = self.current_token.line if self.current_token else None # get the line number
        self.match(TokenType.IF_STMT) # consume the "IF"
        # when we find the LEFT_PAREN
        if self.current_token and self.current_token.token_type == TokenType.LEFT_PAREN:
            self.advance()  # consume it
            self.logic_expr() # parse the logical expression
            # when we find the RIGHT_PAREN
            if self.current_token and self.current_token.token_type == TokenType.RIGHT_PAREN:
                self.advance() # consume it
                self.statements() # parse statements
                # when we find the END_IF
                if self.current_token and self.current_token.token_type == TokenType.END_IF:
                    self.advance()  #consume it
                else:
                    self.error("Expecting 'end_if'", start_line) # error
            else:
                self.error("Expecting right parenthesis ')'", start_line) # error
        else:
            self.error("Expecting left parenthesis '('", start_line) # error

    # <loop_statement> -> loop ( <var> = <expr> : <expr> ) <statements> end_loop
    def loop_statement(self):
        start_line = self.current_token.line if self.current_token else None # get the line number
        self.match(TokenType.LOOP)  # consume the "LOOP"
        # when we find LEFT_PAREN
        if self.current_token and self.current_token.token_type == TokenType.LEFT_PAREN:
            self.advance()  # consume it
            self.var() # parse the var
            # when we find the ASSIGN_OP
            if self.current_token and self.current_token.token_type == TokenType.ASSIGN_OP:
                self.advance() # consume it
                self.var_or_literal() # parse the var/literal
                # when we find the COLON
                if self.current_token and self.current_token.token_type == TokenType.COLON:
                    self.advance()  # consume it
                    self.var_or_literal() # parse the var/literal
                    # when we encounter the RIGHT_PAREN
                    if self.current_token and self.current_token.token_type == TokenType.RIGHT_PAREN:
                        self.advance()  # consume it
                        self.statements() # parse statements
                        # when we encounter the END_LOOP
                        if self.current_token and self.current_token.token_type == TokenType.END_LOOP:
                            self.advance()  #consume it
                        else:
                            self.error("Expecting 'end_loop'", start_line) # error
                    else:
                        self.error("Expecting right parenthesis ')'", start_line) # error
                else:
                    self.error("Expecting colon ':'", start_line) # error
            else:
                self.error("Expecting assignment operator '='", start_line) # error
        else:
            self.error("Expecting left parenthesis '('", start_line) # error

    # <logic_expr> → <rel_expr> {(&& | ||) <rel_expr>} | ( <logic_expr> )
    def logic_expr(self):
        # when we encounter LEFT_PAREN
        if self.current_token and self.current_token.token_type == TokenType.LEFT_PAREN:
            self.advance()  # consume it
            self.logic_expr() # parse logical expression
            # when we encounter the RIGHT_PAREN
            if self.current_token and self.current_token.token_type == TokenType.RIGHT_PAREN:
                self.advance()  # consume it
            else:
                self.error("Expecting right parenthesis ')'") # error
            # when we encounter "&&" / "||"
            while self.current_token and self.current_token.token_type in [TokenType.LOGICAL_AND, TokenType.LOGICAL_OR]:
                self.advance()  # consume them
                self.logic_expr() # parse logical expression
        else:
            self.rel_expr() # parse the relative expression
            # when we encounter "&&" / "||"
            while self.current_token and self.current_token.token_type in [TokenType.LOGICAL_AND, TokenType.LOGICAL_OR]:
                self.advance()  # consume it
                self.rel_expr() # parse the relative expression

    # <rel_expr> -> <expr> <rel_op> <expr>
    def rel_expr(self):
        self.expr() # parse the expression
        self.rel_op() # parse the operator
        self.expr() # parse the other expression

    # <rel_op> -> == | != | > | < | >= | <=
    def rel_op(self):
        # if the current token is a REL_OP
        if self.current_token and self.current_token.token_type in [
            TokenType.EQUALS, TokenType.NOT_EQUALS,
            TokenType.GREATER_THAN, TokenType.LESS_THAN,
            TokenType.GREATER_EQ, TokenType.LESS_EQ
        ]:
            self.advance()  # consume it
        else:
            self.error("Expecting relational operator (==, !=, >, <, >=, <=)") # error

    def parse(self):
        self.program()
        return "Parsing completed successfully"
